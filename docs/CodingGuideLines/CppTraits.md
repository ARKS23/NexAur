# C++特性运用
### 右值引用
- 有时移动拷贝能带来巨大的性能提升，很可能不再进行大量的数据复制而只是简单地进行指针操作。比如使用`std::unique_ptr`的时候`std::move`是必须的。

### 函数重载
- 如果函数单单靠不同的参数类型而重载（acgtyrant 注：这意味着参数数量不变），读者就得十分熟悉 C++ 五花八门的匹配规则，以了解匹配过程具体到底如何。另外，当派生类只重载了某个函数的部分变体，继承语义容易令人困惑。
- 建议做法: 如果打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用`AppendString()`和 `AppendInt()`等， 而不是一口气重载多个`Append()`.

### 缺省参数
- 建议做法: 尽量不使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。
- 原因
  1. 缺省参数会干扰函数指针
  2. 缺省参数在每个调用点都有重复
- 特殊情况下使用缺省参数
  1. 静态函数或匿名空间函数，只能在局部文件里调用该函数
  2. 构造函数中使用缺省参数，因为不能取得构造函数的地址

### 友元
- 允许**合理地**使用友元类和友元函数，友元扩大了类的封装边界，但大多数时候不必使用友元
- 建议做法: 友元通常应该定义在同一个文件内

### 异常
- 按照**Google coding style**不使用C++异常

### 运行时类型识别
- 引擎核心模块中禁止使用RTTI
- RTTI鼓励面向类型的编程，系统行为依赖“具体的类型”，会导致模块强耦合，系统扩展性差。

### 类型转换
- 使用C++的类型转换如`static_cast<>()`,不要使用C风格的类型转换如`int y = (int)x`

### 前置自增和自减
- 做法: 对其迭代器和其他模板对象使用前缀形式`++i`的自增和自减运算符。

### constexpr
- 做法：在C++11里，用constexpr来定义真正的常量或者实现常量初始化。

### 预处理宏
- 建议：使用宏的时候要谨慎，尽量用内联函数、枚举和常量替代。

### `0`, `nullptr`和`NULL`
- 做法: 指针使用`nullptr`, 字符使用`\0`, 不使用`NULL`

### `auto`关键字的使用
- 尽量不要用auto，但是遇到**复杂的类型名称**可以用`auto`，主要以代码的可读性为主.
- 做法
```
auto只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 auto 变量。

auto 还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在 lambda 表达式里。
```

### 列表初始化
- 做法: 可以使用列表初始化
```C++
struct Point { int x; int y; };
Point p = {1, 2};

class MyType {
 public:
  // std::initializer_list 专门接收 init 列表。
  // 得以值传递。
  MyType(std::initializer_list<int> init_list) {
    for (int i : init_list) append(i);
  }
  MyType& operator=(std::initializer_list<int> init_list) {
    clear();
    for (int i : init_list) append(i);
  }
};
MyType m{2, 3, 5, 7};
```
- 禁止行为，不要使用初始化列表初始化auto变量
```C++
// 迷惑行为代码，禁止！
auto d = {1.23};        // d 即是 std::initializer_list<double>
```

### Lambda表达式
- 建议: 适当使用lambda表达式，当lambda将转移当前作用域的时候，首选显式捕获。
```C++
{
  Foo foo;
  ...
  executor->Schedule([&foo] { Frobnicate(foo); })
  ...
}
```

### 模板编程
- 建议：不要使用复杂的模板编程
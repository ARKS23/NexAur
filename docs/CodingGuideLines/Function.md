# 函数
### 输入和输出
- 优先按值返回，其次引用返回。避免返回指针，除非指针可以为空。
- 尽量不使用传出参数，传出参数容易造成全局混乱的情况。

### 编写简短的函数
- 如果一个函数的长度超过50行，考虑是否可以在不影响程序结构的前提下进行分割。
- 在处理代码时, 可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试起来很困难, 或者只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.

### 函数重载
- 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.
- 例子
```C++
class MyClass {
    public:
    void Analyze(const string &text);
    void Analyze(const char *text, size_t textlen);
};
```
- 缺点

如果函数单靠不同的参数类型而重载 (acgtyrant 注：这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体, 继承语义就容易令人困惑.

### 缺省参数
- 只允许在**非虚函数**中使用**缺省参数**, 且必须保证缺省参数的值始终一致. 缺省参数与函数重载遵循同样的规则. **一般情况下建议使用函数重载**, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.
- 对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像 `void f(int n = counter++);` 这样的代码.)

### 函数返回类型后置语法
- 只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.
```C++
// 正常写法
int foo(int x);

// 后置返回类型写法
auto foo(int x) -> int;

template <class T, class U> auto add(T t, U u) -> decltype(t + u);

template <class T, class U> decltype(declval<T&>() + declval<U&>()) add(T t, U u);
```
- 在大部分情况下, 应当继续使用以往的函数声明写法, 即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式) 或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法. 但是后一种情况一般来说是很少见的, 大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样 复杂的模板代码.